<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=600">
  <title>canvas spoof fingerprinting</title>
  <link rel="stylesheet" type="text/css" href="testindex.css">
  <script src="testglobals.js"></script>
  <script src="testgeneric.js"></script>
	<script src="testmain.js"></script>
	<style>
		table {width: 580px;}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb9">
		<col width="25%"><col width="75%">
		<thead><tr><th colspan="2">
			<div class="nav-title"><a href="#screen">canvas spoof fingerprinting</a>
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">Creates a random canvas with known results, reads it back, and analyzes
				the	differences. <code>getImageData</code> is being tested, but <code>toDataURL</code> and
				<code>toBlob</code> can also be "decoded" (albeit a little differently)</span>
		</td></tr>
		<tr><td><div class="btn-left"><button class="btn9 btn" onClick="run()">[ re-run ]</button></div>large visual</td>
			<td><canvas id="cnv" width="100" height="100" style="border:5px solid white;"></canvas></td></tr>
		<tr><td>getImageData</td>
			<td><canvas id="cnv1" width="20" height="20" style="border:5px solid white;"></canvas></td>
		</tr>
		<tr><td>toDataURL | toBlob</td>
			<td>
				<image id="cnv4" width="20" height="20"  style="border:5px solid white;" src=""></image> &nbsp
				<image id="cnv5" width="20" height="20"  style="border:5px solid white;" src=""></image> &nbsp
		</tr>

		<tr><td colspan="2"></td></tr> <!-- spacer -->
		<tr><td></td><td class="s9">------</td></tr>
		<tr><td colspan="2"></td></tr> <!-- spacer -->
		<tr><td>set value</td><td class="c mono" id="sethash"></td></tr>
		<tr><td>read value</td><td class="c mono" id="readhash"></td></tr>

		<tr><td>stats</td><td class="c mono" id="readstats"></td></tr>
		<tr><td>diffs</td><td class="c mono" id="readdiff"></td></tr>

	</table>
	<br>

<script>

function run() {

	let clrSet = [], cellSet = [],
		clrRead = [], cellRead = [],
		hashSet = "",
		hashGetImage = ""
	// clear
	let items = document.getElementsByClassName("c")
	for(let i=0; i < items.length; i++) {
		items[i].innerHTML = "&nbsp"
	}

	// pause so users see change
	setTimeout(function(){
		try {
			let t0 = performance.now()

			let canvas = dom.cnv,
				canvas1 = dom.cnv1,
				canvas4 = dom.cnv4

			if (canvas.getContext) {
				let ctx = canvas.getContext('2d'),
					ctx1 = canvas1.getContext('2d')

				// set
				for (let x=0; x < 20; x++) {
					for (let y=0; y < 20; y++) {
						// get random color
						let clrR = Math.floor(Math.random()*256),
							clrG = Math.floor(Math.random()*256),
							clrB = Math.floor(Math.random()*256)
						let clrs = clrR +","+ clrG + ","+ clrB + ",255"
						clrSet.push(clrR)
						clrSet.push(clrG)
						clrSet.push(clrB)
						clrSet.push(255)
						cellSet.push(clrs)
						// view
						ctx.fillStyle = "rgba(" + clrs + ")"
						ctx.fillRect(x*5, y*5, 5, 5)
						// ?
						ctx1.fillStyle = "rgba(" + clrs + ")"
						ctx1.fillRect(x, y, 1, 1)
					}
				}
				hashSet = sha1(clrSet.join())
				dom.sethash = hashSet

				// toDataURL
				let dataURL = cnv1.toDataURL("image/png")
				cnv4.src = dataURL

				// toBlob
				cnv1.toBlob(function(blob) {
					let url = URL.createObjectURL(blob)
					cnv5.src = url
				})

				// mozGetAsFile
				//try {
				//	let moz = cnv1.mozGetAsFile("moz.png")
				//	let reader = new FileReader()
				//	reader.readAsDataURL(moz)
				//	reader.onloadend = function() {
				//	 cnv6.src = reader.result;
				//	}
				//} catch(err) {}

				// non canvas, read pixels, 20x20
				let img4 = cnv4,
					imgW = img4.width,
					imgH = img4.height
				//console.debug(imgW, imgH)
				// test just do the first four pixels on first row
				for (let x=0; x < 4; x++) {
					for (let y=0; y < 1; y++) {
						//console.debug(x,y)
					}
				}

				// read: getImageData
				for (let x=0; x < 20; x++) {
					for (let y=0; y < 20; y++) {
						let pixel = ctx1.getImageData(x,y,1,1)
						clrRead.push(pixel.data[0])
						clrRead.push(pixel.data[1])
						clrRead.push(pixel.data[2])
						clrRead.push(pixel.data[3])
						cellRead.push(pixel.data[0] +","+ pixel.data[1] +","+ pixel.data[2] +","+ pixel.data[3])
					}
				}
				hashGetImage = sha1(clrRead.join())
				if (hashGetImage == hashSet) {
					dom.readhash = hashGetImage
				} else {
					dom.readhash.innerHTML = sb + hashGetImage + sc

					// analyze
					let changeR = [], changeG = [], changeB = [], changeA = [], changeC = [], channels = []
					let absR = [], absG = [], absB = []
					let negR = 0, negG = 0, negB = 0, z = 0
					let chan = ""

					for (let i=0; i < clrSet.length; i++) {
						let diff = clrRead[i] - clrSet[i]
						if (z==0) {
							if (diff !== 0) {chan += "r"; changeR.push(diff); absR.push(Math.abs(diff)); if(diff < 0) {negR++}}
							z = 1
						} else if (z==1) {
							if (diff !== 0) {chan += "g"; changeG.push(diff); absG.push(Math.abs(diff)); if(diff < 0) {negG++}}
							z = 2
						} else if (z==2) {
							if (diff !== 0) {chan += "b"; changeB.push(diff); absB.push(Math.abs(diff)); if(diff < 0) {negB++}}
							z = 3
						} else {
							if (diff !== 0) {chan += "a"; changeA.push(diff)}
							if (chan !== "") {channels.push(chan)}
							z = 0
							chan = ""
						}
					}
					for (let i=0; i < cellSet.length; i++) {
						if (cellSet[i] !== cellRead[i]) {
							changeC.push(i)
							// x = i % 10, y = Math.floor(i/10)
						}
					}

					// channels
					let counts = {}
					channels.forEach(function(c) {
						counts[c] = (counts[c] || 0) + 1
					})
					let tmpchan = channels.filter(function(item, position) {return channels.indexOf(item) === position})
					tmpchan.sort()

					let chancount = 0, chanstring = ""
					if (changeR.length > 0) {chancount++; chanstring = "r"}
					if (changeG.length > 0) {chancount++; chanstring += "g"}
					if (changeB.length > 0) {chancount++; chanstring += "b"}
					if (changeA.length > 0) {chancount++; chanstring += "a"}

					// stats
					dom.readstats.innerHTML = "    cells changed: " + changeC.length
						+ "<br> channels changed: "+ chancount + " [" + chanstring + "]"
						+ "<br>   channel counts: r: "+ changeR.length
						+ ", g: "+ changeG.length
						+ ", b: "+ changeB.length
						+ ", a: "+ changeA.length
						+ "<br>   combos altered: " + tmpchan.length + " [" + tmpchan.join(", ") + "]"
						+ "<br>     combo counts: " + JSON.stringify(counts)

					// diffs
					let tmpR = changeR.filter(function(item, position) {return changeR.indexOf(item) === position})
					let tmpG = changeG.filter(function(item, position) {return changeG.indexOf(item) === position})
					let tmpB = changeB.filter(function(item, position) {return changeB.indexOf(item) === position})
					let tmpA = changeA.filter(function(item, position) {return changeA.indexOf(item) === position})
					// sort diffs numerically
					tmpR.sort(function(a, b){return a-b})
					tmpG.sort(function(a, b){return a-b})
					tmpB.sort(function(a, b){return a-b})
					tmpA.sort(function(a, b){return a-b})
					// for each we want a count and a spread (max/min)
					// +/- split (ignore a)
					let strR = "n/a", strG = "n/a", strB = "n/a", strA = "n/a"
					if (tmpR.length > 0) {
						strR = tmpR.length +" ["+ tmpR[0] +" to "+ tmpR[tmpR.length-1] + ", " + (tmpR[tmpR.length-1]-tmpR[0]) +"]"
						strR += " " + negR + "/" + (changeR.length-negR)
					}
					if (tmpG.length > 0) {
						strG = tmpG.length +" ["+ tmpG[0] +" to "+ tmpG[tmpG.length-1] + ", " + (tmpG[tmpG.length-1]-tmpG[0]) +"]"
						strG += " " + negG + "/" + (changeG.length-negG)
					}
					if (tmpB.length > 0) {
						strB = tmpB.length +" ["+ tmpB[0] +" to "+ tmpB[tmpB.length-1] + ", " + (tmpB[tmpB.length-1]-tmpB[0]) +"]"
						strB += " " + negB + "/" + (changeB.length-negB)
					}
					if (tmpA.length > 0) {
						strA = tmpA.length +" ["+ tmpA[0] +" to "+ tmpA[tmpA.length-1] + ", " + (tmpA[tmpA.length-1]-tmpA[0]) +"]"
					}
				
					// absolute stats (ignore a)
					tmpR = absR.filter(function(item, position) {return absR.indexOf(item) === position})
					tmpG = absG.filter(function(item, position) {return absG.indexOf(item) === position})
					tmpB = absB.filter(function(item, position) {return absB.indexOf(item) === position})
					tmpR.sort(function(a, b){return a-b})
					tmpG.sort(function(a, b){return a-b})
					tmpB.sort(function(a, b){return a-b})
					if (tmpR.length > 0) {
						strR += " ... " + tmpR.length +" ["+ tmpR[0] +" to "+ tmpR[tmpR.length-1] + ", " + (tmpR[tmpR.length-1]-tmpR[0]) +"]"
					}
					if (tmpG.length > 0) {
						strG += " ... " + tmpG.length +" ["+ tmpG[0] +" to "+ tmpG[tmpG.length-1] + ", " + (tmpG[tmpG.length-1]-tmpG[0]) +"]"
					}
					if (tmpB.length > 0) {
						strB += " ... " + tmpB.length +" ["+ tmpB[0] +" to "+ tmpB[tmpB.length-1] + ", " + (tmpB[tmpB.length-1]-tmpB[0]) +"]"
					}

					dom.readdiff.innerHTML = "  r: "+ strR
						+ "<br>  g: "+ strG + "<br>  b: "+ strB + "<br>  a: "+ strA 

				}

				// perf
				let t1 = performance.now()
				dom.perf.innerHTML = Math.round(t1-t0) + "ms"

			}
		} catch(e) {
			console.debug("catchall", e.name, e.message)
		}
	}, 170)

}

run()

</script>
</body>
</html>
