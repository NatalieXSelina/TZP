<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>pluralrules</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
	<title>pluralrules</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">pluralrules</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A proof to confirm the minimum set of numbers to return maximum entropy in Intl.pluralRules</span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<div id="button" class="btn"><span class="btn4 btn" onClick="run()">[ run ]</span></div>
				<span class="spaces" id="perf0"></span><span id="perf2"></span><span id="perf1"></span>
				<br><span class="spaces" id="numbers1"></span>
				<br><span class="spaces" id="results1"></span>
				<br><span class="spaces" id="numbers0"></span>
				<br><span class="spaces" id="results0"></span>
			</td></tr>
	</table>
	<br>

<script>
var locales = [],
	list = [],
	list_one = [], // first change of each result
	main_buckets = [],
	isDebug = false,
	debug0 = [],
	debug1 = []

var detailed = [
"aa,afar",
"ab,abkhazian",
"ach,acholi",
"ae,avestan",
"af,afrikaans",
"ak,akan",
"am,amharic",
"an,aragonese",
"ar,arabic",
"as,assamese",
"ast,asturian",
"av,avaric",
"ay,aymara",
"az,azerbaijani",
"ba,bashkir",
"be,belarusian",
"bg,bulgarian",
"bh,bihari",
"bi,bislama",
"bm,bambara",
"bn,bengali",
"bo,tibetan",
"br,breton",
"bs,bosnian",
"ca,catalan",
"cak,kaqchikel",
"ce,chechen",
"ch,chamorro",
"ckb,central kurdish", // ? dropped
"co,corsican",
"cr,cree",
"crh,crimean tatar",
"cs,czech",
"csb,kashubian",
"cu,church slavic",
"cv,chuvash",
"cy,welsh",
"da,danish",
"de,german",
"dsb,lower sorbian",
"dv,divehi",
"dz,dzongkha",
"ee,ewe",
"el,greek",
"en,english",
"eo,esperanto",
"es,spanish",
"et,estonian",
"eu,basque",
"fa,persian",
"ff,fulah",
"fi,finnish",
"fj,fijian",
"fo,faroese",
"fr,french",
"fur,friulian",
"fy,frisian",
"ga,irish",
"gd,scottish gaelic",
"gl,galician",
"gn,guarani",
"gu,gujarati",
"gv,manx",
"ha,hausa",
"haw,hawaiian",
"he,hebrew",
"hi,hindi",
"hil,hiligaynon",
"ho,hiri motu",
"hr,croatian",
"hsb,upper sorbian",
"ht,haitian",
"hu,hungarian",
"hy,armenian",
"hye,eastern armenian", // ? dropped
"hz,herero",
"ia,interlingua",
"id,indonesian",
"ie,interlingue",
"ig,igbo",
"ii,sichuan yi",
"ik,inupiaq",
"io,ido",
"is,icelandic",
"it,italian",
"iu,inuktitut",
"ja,japanese",
"jv,javanese",
"ka,georgian",
"kab,kabyle",
"kg,kongo",
"ki,kikuyu",
"kj,kuanyama",
"kk,kazakh",
"kl,greenlandic",
"km,khmer",
"kn,kannada",
"ko,korean",
"kok,konkani",
"kr,kanuri",
"ks,kashmiri",
"ku,kurdish",
"kv,komi",
"kw,cornish",
"ky,kirghiz",
"la,latin",
"lb,luxembourgish",
"lg,ganda",
"li,limburgan",
"lij,ligurian",
"ln,lingala",
"lo,lao",
"lt,lithuanian",
"ltg,latgalian",
"lu,luba-katanga",
"lv,latvian",
"mai,maithili",
"meh,sw tlaxiaco mixtec",
"mg,malagasy",
"mh,marshallese",
"mi,maori",
"mix,mixtepec mixtec",
"mk,macedonian",
"ml,malayalam",
"mn,mongolian",
"mr,marathi",
"ms,malay",
"mt,maltese",
"my,burmese",
"na,nauru",
"nb,norwegian bokmål",
"nd,ndebele north",
"ne,nepali",
"ng,ndonga",
"nl,dutch",
"nn,norwegian nynorsk",
"no,norwegian",
"nr,ndebele south",
"nso,sotho northern",
"nv,navajo",
"ny,chichewa",
"oc,occitan",
"oj,ojibwa",
"om,oromo",
"or,odia",
"os,ossetian",
"pa,punjabi",
"pi,pali",
"pl,polish",
"ps,pashto",
"pt,portuguese",
"qu,quechua",
"rm,rhaeto-romanic",
"rn,kirundi",
"ro,romanian",
"ru,russian",
"rw,kinyarwanda",
"sa,sanskrit",
"sc,sardinian",
"sco,scots", // 1714293
"sd,sindhi",
"se,northern sami",
"sg,sango",
"si,singhalese",
"sk,slovak",
"sl,slovenian",
"sm,samoan",
"sn,shona",
"so,somali",
"son,songhay",
"sq,albanian",
"sr,serbian",
"ss,siswati",
"st,sotho southern",
"su,sundanese",
"sv,swedish",
"sw,swahili",
"szl,silesian", // 1691695
"ta,tamil",
"te,telugu",
"tg,tajik",
"th,thai",
"ti,tigrinya",
"tig,tigre",
"tk,turkmen",
"tl,tagalog",
"tlh,klingon",
"tn,tswana",
"to,tonga",
"tr,turkish",
"trs,triqui", // 1583177
"ts,tsonga",
"tt,tatar",
"tw,twi",
"ty,tahitian",
"ug,uighur",
"uk,ukrainian",
"ur,urdu",
"uz,uzbek",
"ve,venda",
"vi,vietnamese",
"vo,volapük",
"wa,walloon",
"wen,sorbian",
"wo,wolof",
"xh,xhosa",
"yi,yiddish",
"yo,yoruba",
"za,zhuang",
"zam,miahuatlán zapotec",
"zh,chinese",
"zh-cn,chinese china",
"zh-Hans,chinese simple",
"zh-Hant,chinese traditional",
"zh-hk,chinese hong kong",
"zh-sg,chinese singapore",
"zh-tw,chinese taiwan",
"zu,zulu",
]

function start() {
	// builds locales array and outputs a legend
	detailed.sort()
	try {
		let legend = []
		for (let i = 0 ; i < detailed.length; i++) {
			// split: A (code), B (name)
			let listA = detailed[i].split(",")[0]
			let listB = detailed[i].split(",")[1]
			locales.push(listA)
			legend.push(listA.padStart(7) +": "+ listB)
		}
		dom.legend.innerHTML = s4 +"   LEGEND ("+ locales.length +")"+ sc +"<br><br>"+ legend.join("<br>")
	} catch(e) {}
}

function run_test(type) {

	// vars
	let t0 = performance.now()
	let test_array = [], // numbers used
		test_all = [], // result hash + locale code + result
		go = true,
		perfname = "all"
		str = "",
		sColor = s12.trim()

	let	element = document.getElementById("results" + type)
	let	elperf = document.getElementById("perf" + type)

	// main test
	if (type == "0") {
		// reset
		list = []
		list_one = []
		main_buckets = []
		// build
		for (let i=0; i < 101; i++) {list.push(i)}
		// temp smaller tests
		//list = [0,1,2,3,4,6,7,11,20,21,100]
		//list = [1,2,3,4,5,25,134,910293019,12,1412,15,2931,31231,3123,13231,91,0,231,33,728,2,291,24,479,291,778,919,93]
		//locales = ['ar','br','bs','cs','cy','en','fr','ga','gd','gv','he','is','kw','lt','lv','mt','pl','ro','ru','sl','zh',]
		//locales = ['ar','bo','bn','dz','en','fa','fi','gd','he','kw','ku','lv','se','sl','ss',]
		test_array = list
	}

	// subsequent tests
	if (list.length == 0) {
		go = false
		console.debug("ABORTED: run the main test first")
	}

	if (go) {
		// small test
		if (type == "1") {
			test_array = list_one
			if (isEngine == "blink") {
				test_array.push(81) // chromium to keep lij unique from it,sc in ordinal (bug?)
			}
			perfname = "first changes only"
		}
		// always sort the array
		test_array.sort((a,b) => a-b)

		// for each locale
		for (let j=0; j < locales.length; j++) {
			// reset cardinal
			let prevC = "", currentC = "", tmp_resultC = []
			c0 = true, c1 = true, c2 = true, c3 = true, c4 = true, c5 = true
			// reset ordinal
			let prevO = "", currentO = "", tmp_resultO = []
			o0 = true, o1 = true, o2 = true, o3 = true, o4 = true, o5 = true

			let code = locales[j]
			// list
			for (let k=0; k < test_array.length; k++) {
				let n = test_array[k]
				// cardinal
				try {
					currentC = new Intl.PluralRules(code, {type:"cardinal"}).select(n)
					if (type == "0") {
						// catch first
						if (c0 && currentC == "zero") {c0 = false; list_one.push(n)}
						if (c1 && currentC == "one") {c1 = false; list_one.push(n)}
						if (c2 && currentC == "two") {c2 = false; list_one.push(n)}
						if (c3 && currentC == "few") {c3 = false; list_one.push(n)}
						if (c4 && currentC == "many") {c4 = false; list_one.push(n)}
						if (c5 && currentC == "other") {c5 = false; list_one.push(n)}
					}
				} catch(e) {
					currentC = "error"
				}
				// record all changes
				if (prevC !== currentC) {
					tmp_resultC.push(n +": "+ currentC)
				}
				prevC = currentC

				// ordinal
				try {
					currentO = new Intl.PluralRules(code, {type:"ordinal"}).select(n)
					if (type == "0") {
						// catch first
						if (o0 && currentO == "zero") {o0 = false; list_one.push(n)}
						if (o1 && currentO == "one") {o1 = false; list_one.push(n)}
						if (o2 && currentO == "two") {o2 = false; list_one.push(n)}
						if (o3 && currentO == "few") {o3 = false; list_one.push(n)}
						if (o4 && currentO == "many") {o4 = false; list_one.push(n)}
						if (o5 && currentO == "other") {o5 = false; list_one.push(n)}
					}
				} catch(e) {
					currentO = "error"
				}
				// record all changes
				if (prevO !== currentO) {
					tmp_resultO.push(n +": "+ currentO)
				}
				prevO = currentO
			}
			// array: hash-combined + code + resultC + resultO
			let strC = tmp_resultC.join(", ")
			let hashC = sha1(strC)
			let strO = tmp_resultO.join(", ")
			let hashO = sha1(strO)
			let hashCombined = sha1(hashC + hashO)
			test_all.push(hashCombined +"~"+ code +"~"+ strC +"~"+ strO)

			if (isDebug) { // example
				if (code == "lij" || code == "it" || code == "sc") {
					if (type == "0") {
						debug0.push(code)
						debug0.push(hashC +":"+ strC)
						debug0.push(hashO +":"+ strO)
					} else {
						debug1.push(code)
						debug1.push(hashC +":"+ strC)
						debug1.push(hashO +":"+ strO)
					}
				}
			}
		}
		// set things in main test for small test
		if (type == "0") {
			// first changes
			list_one = list_one.filter(function(item, position) {return list_one.indexOf(item) === position})
			list_one.sort((a,b) => a-b)
		} else if( type == "1") {
			let blinkStr = isEngine == "blink" ? " [81 added for blink + lij]" : ""
			dom.numbers1.innerHTML = "<hr><br>" + s4.trim() + perfname.toUpperCase() +" ("
				+ list_one.length +")"+ sc + blinkStr +"<br><br>"+ list_one.join(", ")
			if (isDebug) {
				console.debug("BIG test\n - " + debug0.join("\n - "))
				console.debug("SMALL test\n - " + debug1.join("\n - "))
			}
		}
		// perf
		let perf = perfname +" "+ s4.trim() + Math.round(performance.now()-t0) + sc +" ms"
		elperf.innerHTML = (type == "0" ? s4.trim() +"PERF: "+ sc : " | ") + perf
			+ (type == "1" ? "<br>" : "")

		// sort array & loop: get hash + code + result buckets, and code_total
		test_all.sort()
		let bucket_hash = [], bucket_code = [], bucket_resC = [], bucket_resO = []
		let tmp_code = [], nextHash = "", code_total = 0

		for (let i=0; i < test_all.length; i++) {
			let part1 = test_all[i].split("~")[0],
				part2 = test_all[i].split("~")[1],
				part3 = test_all[i].split("~")[2],
				part4 = test_all[i].split("~")[3]
			// build code string
			tmp_code.push(part2)
			// grab next item
			if (i < test_all.length - 1) {
				nextHash = test_all[(i+1)].split("~")[0]
			} else {
				nextHash = "end"
			}
			// next hash is diff: write data
			if (nextHash !== part1) {
				bucket_hash.push(part1 + s4 +"("+ tmp_code.length +")"+ sc)
				bucket_resC.push(part3)
				bucket_resO.push(part4)
				bucket_code.push(tmp_code.join(", "))
				code_total += tmp_code.length
				tmp_code = [] // reset tmp_code
			}
		}

		// main
		if (type == "0") {
			// build pretty BEFORE sorting
			let pretty = []
			for (let i=0; i < bucket_hash.length; i++) {
				let part1 = s4 +"hash: "+ sc + bucket_hash[i]
				let part2 = "<ul><li>" + sColor +"cardinal: "+ sc + bucket_resC[i] +"</li>"
				let part3 = "<li>" + sColor +"ordinal: "+ sc + bucket_resO[i] +"</li>"
				let part4 = "<li>" + sColor +"locale: "+ sc + bucket_code[i] +"</li></ul>"
				pretty.push(part1 + part2 + part3 + part4)
			}
			// remember main details
			main_buckets = bucket_code
			main_buckets.sort()
			// output
			str = code_total + (code_total == locales.length ? sg : sb) +"[match]"+ sc
			str = "<hr><br>"+ s4.trim() +"ALL NUMBERS ("+ list.length +")"+ sc +"<br>"
				+"<ul><li>"+ sColor +"unique hashes: "+ sc + main_buckets.length +"</li>"
				+"<li>"+ sColor +" locales hash: "+ sc + sha1(main_buckets.join()) +"</li>"
				+"<li>"+ sColor +" locale check: "+ sc + str +"</li></ul>"
			dom.numbers0.innerHTML = str
			element.innerHTML = pretty.join("")
		} else {
			// set vars to compare to main
			bucket_code.sort()
			let check_count = bucket_code.length
			let check_hash = sha1(bucket_code.join())
			let main_hash = sha1(main_buckets.join())
			// append results
			let matchbad = sb +"[match]"+ sc, matchgood = sg +"[match]"+ sc
			str = "<ul><li>" + sColor +"unique hashes:"+ sc
			str += " "+ check_count + (check_count == main_buckets.length ? matchgood : matchbad)
			str += "</li><li>"+ sColor +" locales hash: "+ sc + check_hash + (check_hash == main_hash ? matchgood : matchbad)
			str += "</li></ul>"
			element.innerHTML = str
			if (check_hash !== main_hash) {
				console.debug("MISMATCH\n" + "101 TEST buckets\n", main_buckets, "SMALL TEST buckets\n", bucket_code)
			}
		}
	}
}

function run() {
	//isDebug = true
	dom.button.remove()
	run_test("0") // main test
	run_test("1")
}

start()

</script>
</body>
</html>
