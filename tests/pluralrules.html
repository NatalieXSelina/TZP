<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>pluralrules</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
  <title>pluralrules</title>
  <link rel="stylesheet" type="text/css" href="testindex.css">
  <script src="testglobals.js"></script>
  <script src="testgeneric.js"></script>
	<script src="testmain.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">pluralrules</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color" id="intro"></span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<div id="button" class="btn"><button class="btn4 btn" onClick="run()">[ run ]</button></div>
				<span class="spaces" id="perf0"></span><span id="perf2"></span><span id="perf1"></span>
				<br><span class="spaces" id="numbers1"></span>
				<br><span class="spaces" id="results1"></span>
				<br><span class="spaces" id="numbers2"></span>
				<br><span class="spaces" id="results2"></span>
				<br><span class="spaces" id="numbers0"></span>
				<br><span class="spaces" id="results0"></span>
			</td></tr>
	</table>
	<br>

<script>
var locales = [],
	list = [],
	list_one = [], // first change of each result
	list_all = [], // all numbers that changed
	main_count = 0,
	main_result = "",
	main_code = ""

function start() {
	// builds locales array and outputs a legend
	try {
		let detailed = [
			"aa,afar","ab,abkhazian","ach,acholi","ae,avestan","af,afrikans","ak,akan","am,amharic","an,arahonese","ar,arabic",
			"as,assamese","ast,asturian","av,avaric","ay,aymara","az,azerbijani","ba,bashkir","be,belarusian","bg,bulgarian",
			"bh,bihari","bi,bislama","bm,bambara","bn,bengali","bo,tibetan","br,breton","bs,bosnian","ca,catalan","cak,kaqchikel",
			"ce,chechen","ch,chamorro","ckb,central kurdish","co,corsican","cr,cree","crh,crimean tatar","cs,czech",
			"csb,kashubian","cu,church slavic","cv,chuvash","cy,welsh","da,danish","de,german","dsb,lower sorbian",
			"dv,divehi","dz,dzongkha","ee,ewe","el,greek","en,english","eo,esperanto","es,spanish","et,estonian","eu,basque",
			"fa,persian","ff,fulah","fi,finnish","fj,fijian","fo,faroese","fr,french","fur,friulian","fy,frisian","ga,irish",
			"gd,scottish gaelic","gl,galician","gn,guarani","gu,gujarati","gv,manx","ha,hausa","haw,hawaiian","he,hebrew",
			"hi,hindi","hil,hiligaynon","ho,hiri motu","hr,croatian","hsb,upper sorbian","ht,haitian","hu,hungarian",
			"hy,armenian","hye,eastern armenian","hz,herero","ia,interlingua","id,indonesian","ie,interlingue","ig,igbo",
			"ii,sichuan yi","ik,inupiaq","io,ido","is,icelandic","it,italian","iu,inuktitut","ja,japanese","jv,javanese","ka,georgian",
			"kab,kabyle","kg,kongo","ki,kikuyu","kk,kazakh","kl,greenlandic","km,khmer","kn,kannada","ko,korean","kok,konkani",
			"kr,kanuri","ks,kasmiri","ku,kurdish","kv,komi","kw,cornish","ky,kirghiz","la,latin","lb,luxembourgish","lg,ganda",
			"li,limburgan","lij,ligurian","ln,lingala","lo,lao","lt,lithuanian","ltg,latgalian","lu,luba-katanga","lv,latvian",
			"mai,maithili","meh,mixteco tucuhiti","mg,malagasy","mh,marshallese","mi,maori","mix,mixtepec mixtec",
			"mk,macedonian","ml,malayalam","mn,mongolian","mr,marathi","ms,malay","mt,maltese","my,burmese","na,nauru",
			"nb,norwegian bokmal","nd,ndebele north","ne,nepali","ng,ndonga","nl,dutch","nn,norwegian nynorsk","no,norwegian",
			"nr,ndebele south","nso,sotho northern","nv,navajo","ny,chichewa","oc,occitan","oj,ojibwa","om,oromo","or,odia",
			"os,ossetian","pa,punjabi","pi,pali","pl,polish","ps,pashto","pt,portuguese","qu,quechua","rm,rhaeto-romantic",
			"rn,kirundi","ro,romanian","ru,russian","rw,kinyarwanda","sa,sanskrit","sc,sardinian","sd,sindhi","sg,sango",
			"si,singhalese","sk,slovak","sl,slovenian","sm,samoan","so,somalian","son,songhay","sq,albanian","sr,serbian",
			"ss,siswati","st,sotho southern","su,sudanese","sv,swedish","sw,swahili","ta,tamil","te,teluga","tg,tajik",
			"th,thai","ti,tigrinya","tig,tigre","tk,turkmen","tlh,klingon","tn,tswana","to,tonga","tr,turkish","trs,triqui",
			"ts,tsonga","tt,tatar","tw,twi","ty,tahitian","ug,uighur","uk,ukranian","ur,urdu","uz,uzbek","ve,venda",
			"vi,vietnamese","vo,volapuk","wa,walloon","wo,wolof","xh,xhosa","yi,yiddish","yo,yoruba","za,zhuang",
			"zam,miahuatlan zapotec","zh,chinese","zh-cn,chinese china","zh-Hans,chinese simple","zh-Hant,chinese traditional",
			"zh-hk,chinese hong kong","zh-sg,chinese singapore","zh-tw,chinese taiwan","zu,zulu",
		]
		detailed.sort()

		let legend = []
		for (let i = 0 ; i < detailed.length; i++) {
			// split: A (code), B (name)
			let listA = detailed[i].split(",")[0]
			let listB = detailed[i].split(",")[1]
			locales.push(listA)
			legend.push( listA.padStart(7) + ": " + listB  )
		}
		dom.legend.innerHTML = s4 + "   LEGEND" + sc	+ "<br><br>" + legend.join("<br>")
		// intro
		let introstr = "A proof to confirm the minimum set of numbers to return maximum entropy in Intl.pluralRules<br></br>"
		introstr += "Takes"+ s4 + legend.length + " locales" + sc + " and enumerates the unique hashes generated"
			+ " (and lists the locales per hash) when checking all the numbers from" + s4 +"0-101" + sc
		introstr += ". It then discards all numbers that did not change a preceeding result, and re-runs the test to see if "
			+ " the results change in any way. "
		introstr += "And lastly, it reduces the numbers to only those that cause the first change of each result"
			+ " and re-runs the test, checking that the number of unique hashes, and the locales in them, hasn't changed"
		dom.intro.innerHTML = introstr

	} catch(e) {}
}

function run_test(type) {
	// vars
	let t0 = performance.now()
	let test_array = [],
		tmp_res = [], // result per locale
		test_all = [], // result hash + locale code + result
		go = true,
		perfname = "all"
		str = "",
		sColor = s12

	let	element = document.getElementById("results" + type)
	let	elperf = document.getElementById("perf" + type)

	// main test
	if (type == "0") {
		// reset
		list = []
		list_one = []
		list_all = []
		main_count = 0,
		main_reshash = "",
		main_codehash = ""
		// build
		for (let i=0; i < 101; i++) {list.push(i)}

		// temp smaller tests
		//list = [0,1,2,3,4,6,7,11,20,21,100]
		//list = [1,2,3,4,5,25,134,910293019,12,1412,15,2931,31231,3123,13231,91,0,231,33,728,2,291,24,479,291,778,919,93]
		//locales = ['ar','br','bs','cs','cy','en','fr','ga','gd','gv','he','is','kw','lt','lv','mt','pl','ro','ru','sl','zh',]
		//locales = ['ar','bo','bn','dz','en','fa','fi','gd','he','kw','ku','lv','sl','ss',]

		test_array = list
	}
	// subsequent tests
	if (list.length == 0) {
		go = false
		console.debug("ABORTED: run the main test first")
	}

	if (go) {
		// always sort the array
		test_array.sort((a,b) => a-b)

		// subsequent tests
		if (type == "1") {
			test_array = list_one
			perfname = "first changes only"
		} else if (type == "2") {
			test_array = list_all
			perfname = "changes only"
		}

		// for each locale
	for (let j=0; j < locales.length; j++) {
			// reset
			let prev = "", current = "", tmp_result = []
			f0 = true, f1 = true, f2 = true, f3 = true, f4 = true, f5 = true
			let code = locales[j]

			// list
			for (let k=0; k < test_array.length; k++) {
				let n = test_array[k]
				try {
					current = new Intl.PluralRules(code).select(n)
					if (type == "0") {
						// catch first
						if (f0 && current == "zero") {f0 = false; list_one.push(n);}
						if (f1 && current == "one") {f1 = false; list_one.push(n);}
						if (f2 && current == "two") {f2 = false; list_one.push(n);}
						if (f3 && current == "few") {f3 = false; list_one.push(n);}
						if (f4 && current == "many") {f4 = false; list_one.push(n);}
						if (f5 && current == "other") {f5 = false; list_one.push(n);}
					}
				} catch(e) {
					current = "error"
				}
				// record all changes
				if (prev !== current) {
					tmp_result.push(n + ": "+ current)
					// main test, record all numbers that change
					if (type == "0") {
						list_all.push(n)
					}
				}
				prev = current
			}
			// array: hash + code + result
			let tmpR = tmp_result.join(", ")
			let tmpH = sha1(tmpR)
			test_all.push(sha1(tmp_result.join()) + "~" + code + "~" + tmpR)
		}

		// set things in main test for subsequent tests
		if (type == "0") {
			// first changes
			list_one = list_one.filter(function(item, position) {return list_one.indexOf(item) === position})
			list_one.sort((a,b) => a-b)
			// all changes
			list_all = list_all.filter(function(item, position) {return list_all.indexOf(item) === position})
			list_all.sort((a,b) => a-b)
		} else if ( type == "1") {
			dom.numbers1.innerHTML = "<hr><br>" + s4.trim() + perfname.toUpperCase() + " ("
				+ list_one.length + ")" + sc + "<br><br>" + list_one.join(", ")
		} else {
			dom.numbers2.innerHTML = "<hr><br>" + s4.trim() + perfname.toUpperCase() + " ("
				+ list_all.length + ")" + sc + "<br><br>" + list_all.join(", ")
		}
		// perf
		let perf = perfname + " " + s4.trim() + Math.round(performance.now()-t0) + sc +" ms"
		elperf.innerHTML = (type == "0" ? s4.trim() + "PERF: " + sc : s4 + " | " + sc) + perf
			+ (type == "1" ? "<br>" : "")

		// sort array & loop: get hash + code + result buckets, and code_total
		test_all.sort()
		let bucket_hash = [], bucket_code = [], bucket_res = []
		let tmp_code = [], nextHash = "", code_total = 0

		for (let i=0; i < test_all.length; i++) {
			let part1 = test_all[i].split("~")[0],
				part2 = test_all[i].split("~")[1],
				part3 = test_all[i].split("~")[2]
			// build code string
			tmp_code.push(part2)
			// grab next item
			if (i < test_all.length - 1) {
				nextHash = test_all[(i+1)].split("~")[0]
			} else {
				nextHash = "end"
			}
			// next hash is diff: write data
			if (nextHash !== part1) {
				bucket_hash.push(part1 + s4 +"("+ tmp_code.length + ")"+sc)
				bucket_res.push(part3)
				bucket_code.push(tmp_code.join(", "))
				code_total += tmp_code.length
				tmp_code = [] // reset tmp_code
			}
		}

		// main
		if (type == "0") {
			// build pretty BEFORE sorting
			let pretty = []
			for (let i=0; i < bucket_hash.length; i++) {
				let part1 = s4 + "hash: " + sc + bucket_hash[i]
				let part2 = "<ul><li>" + sColor.trim() + "result: "  + sc + bucket_res[i] + "</li>"
				let part3 = "<li>" + sColor.trim() + "locale: " + sc + bucket_code[i] + "</li></ul>"
				pretty.push(part1 + part2 + part3)
			}
			// sort and set globals
			main_count = bucket_hash.length
			bucket_res.sort()
			main_result = sha1(bucket_res.join())
			bucket_code.sort()
			main_code = sha1(bucket_code.join())
			// output
			str = code_total + (code_total == locales.length ? sg : sb) + "[match]" + sc
			str = "<hr><br>" + s4.trim() + "ALL NUMBERS (" + list.length + ")"  + sc + "<br>"
				+ "<ul><li>" + sColor.trim() + "unique hashes: " + sc + main_count + "</li>"
				+ "<li>" + sColor.trim() + " results hash: " + sc + main_result + "</li>"
				+ "<li>" + sColor.trim() + " locales hash: " + sc + main_code + "</li>"
				+ "<li>" + sColor.trim() + " locale check: " + sc + str + "</li></ul>"
			dom.numbers0.innerHTML = str
			element.innerHTML = pretty.join("")

		} else {
			// set vars to compare to main
			let check_count = bucket_hash.length
			bucket_res.sort()
			let check_result = sha1(bucket_res.join())
			bucket_code.sort()
			let check_code = sha1(bucket_code.join())
			// append results
			let matchbad = sb + "[match]" + sc, matchgood = sg + "[match]" + sc
			str = "<ul><li>" + sColor.trim() + "unique hashes:" + sc
			if (check_count == main_count) {
				str += sg + " (" + check_count + ")" + matchgood
			} else {
				str += sb + " (" + check_count + ")" + matchbad
			}
			if (type == "2") {
				str += "</li><li>" + sColor.trim() + " results hash: " + sc + check_result + (check_result == main_result ? matchgood : matchbad)
			} else {
				// we know the results hash changes: that's not what we testing for
				str += "</li><li>" + sColor.trim() + " results hash: " + sc + check_result
			}
			str += "</li><li>" + sColor.trim() + " locales hash: " + sc + check_code + (check_code == main_code ? matchgood : matchbad)
			str += "</li></ul>"
			element.innerHTML = str
		}
	}
}

function run() {
	dom.button.remove()
	run_test("0") // main test
	run_test("1")
	run_test("2")
}

start()

</script>
</body>
</html>
