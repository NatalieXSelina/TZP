<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=600">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 580px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
		hr {color: #dcc18c}
	</style>
</head>

<body>
	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">engine</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">An eeny-weeny, teeny-weeny minuscule sample of the thousands of myriad ways engines differ.
			This test is tweaked for gecko: you want <span class="s9"> &#x2713 </span>'s. Anything different
			<span class="bad"> &#x2716 </span> or blocked <span class="bad"> &#x25a0 </span> only makes you stand out.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

s3 = s3.trim()
let results = [],
	data = {},
	count = 0,
	expected = 16

function display() {
	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(data[k])}
	let display = []
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let desc = results[i].split("~~~")[0].trim(),
			result = results[i].split("~~~")[1],
			match = results[i].split("~~~")[2]
		if (desc == "header") {
			display.push("<span>"+ result.toUpperCase() + "</span><br>")
		} else {
			if (match == zB0) {match = red_block} else {match = (match == "true" ? green_tick : red_cross)}
			match += " "
			desc = s3 + desc.padStart(30) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[0].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	dom.results.innerHTML = display.join("<br>")
}

function record(order, description, result, match) {
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match
	count ++
	if (count == expected) {
		display()
	}
	//console.debug(count, order, description)
}

function compute() {
	// HEADERS
	record(0, "header", "expected")
	record(300, "header", "not expected")
	record(600, "header", "specific values")

	// 0+: EXPECTED
	// 20, 21, 22 = error columnNumber, fileName, lineNumber
	let strIT1 = "InstallTrigger in window", testIT1 = false
	try {
		testIT1 = "InstallTrigger" in window
		record (50, strIT1, testIT1, testIT1)
	} catch (e) {
		record(50, strIT1, e.name, zB0)
	}
	let strIT2 = "typeof InstallTrigger", testIT2 = false
	try {
		let resIT2 = typeof InstallTrigger
		if (resIT2 == "object") {testIT2 = true}
		record (51, strIT2, resIT2, testIT2)
	} catch (e) {
		record(51, strIT2, e.name, zB0)
	}
	let strIT3 = "typeof InstallTriggerImpl", testIT3 = false
	try {
		let resIT3 = typeof InstallTriggerImpl
		if (resIT3 == "function") {testIT3 = true}
		record (52, strIT3, resIT3, testIT3)
	} catch (e) {
		record(52, strIT3, e.name, zB0)
	}
	let strNOscpu = "navigator.oscpu", testNOscpu = false
	try {
		let resNOscpu = navigator.oscpu
		if (resNOscpu == "") {resNOscpu = "empty string"
		} else if (resNOscpu == undefined) {resNOscpu = "undefined"
		} else if (resNOscpu == "undefined") {resNOscpu = "undefined string"
		} else {testNOscpu = true}
		record (100, strNOscpu, resNOscpu, testNOscpu)
	} catch (e) {
		record(100, strNOscpu, e.name, zB0)
	}

	// 300+: NOT EXPECTED
	let strWChrome = "chrome in window", testWChrome = false
	try {
		testWChrome = "chrome" in window
		record (350, strWChrome, testWChrome, !testWChrome)
	} catch (e) {
		record(350, strWChrome, e.name, zB0)
	}

	// 600+: SPECIFIC VALUES
	// 650: recursion error
	let strNbuild = "navigator.buildID", testNbuild = false
	try {
		let resNbuild = navigator.buildID
		if (resNbuild == "20181001000000") {testNbuild = true
		} else if (resNbuild == "") {resbuild = "empty string"
		} else if (resNbuild == undefined) {resNbuild = "undefined"
		} else if (resNbuild == "undefined") {resNbuild = "undefined string"}
		record (700, strNbuild, resNbuild, testNbuild)
	} catch (e) {
		record(700, strNbuild, e.name, zB0)
	}
	let strNsub = "navigator.productSub", testNsub = false
	try {
		let resNsub = navigator.productSub
		if (resNsub == "20100101") {testNsub = true
		} else if (resNsub == "") {resNsub = "empty string"
		} else if (resNsub == undefined) {resNsub = "undefined"
		} else if (resNsub == "undefined") {resNsub = "undefined string"}
		record (701, strNsub, resNsub, testNsub)
	} catch (e) {
		record(701, strNsub, e.name, zB0)
	}
	let strNvendor = "navigator.vendor", testNvendor = false
	try {
		let resNvendor = navigator.vendor
		if (resNvendor == "") {resNvendor = "empty string"; testNvendor = true
		} else if (resNvendor == undefined) {resNvendor = "undefined"
		} else if (resNvendor == "undefined") {resNvendor = "undefined string"}
		record (702, strNvendor, resNvendor, testNvendor)
	} catch (e) {
		record(702, strNvendor, e.name, zB0)
	}
	let strStackL = "stack length", testStackL = false
	try {
		let resStackL = get_stacklength()
		if (resStackL == 7168) {testStackL = true}
		record (800, strStackL, resStackL, testStackL)
	} catch (e) {
		record(800, strStackL, e.name, zB0)
	}
}

function get_stacklength() {
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch (e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch (e) {
		// columnNumber
		try {
			let strCN = "error.columnNumber", errCN = false
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			record(20, strCN, resCN, testCN)
		} catch(n) {
			record(20, strCN, resCN, zB0)
		}
		// fileName
		try {
			let strFN = "error.fileName", errFN = false
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			record(21, strFN, resFN, testFN)
		} catch(n) {
			record(21, strFN, resFN, zB0)
		}
		// lineNumber
		try {
			let strLN = "error.lineNumber", errLN = false
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			record(22, strLN, resLN, testLN)
		} catch(n) {
			record(22, strLN, resFN, zB0)
		}
		let strRE = "recursion error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			record(650, strRE, resRE, true)
			return e.stack.toString().length
		} else {
			record(650, strRE, resRE, false)
			return e.stack.toString().length
		}
	}
}

setTimeout(function() {
	compute()
}, 100)

</script>
</body>
</html>
